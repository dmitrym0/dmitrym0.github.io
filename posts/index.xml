<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Dmitry M - Veridis Quo</title>
    <link>https//dmitrym0.github.com/posts/</link>
    <description>Recent content in Posts on Dmitry M - Veridis Quo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 12 Jan 2020 00:00:00 -0800</lastBuildDate>
    
	<atom:link href="https//dmitrym0.github.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Swift optionals for Objective-C programmers</title>
      <link>https//dmitrym0.github.com/posts/swift-optionals-for-objc-programmers/</link>
      <pubDate>Sun, 12 Jan 2020 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/swift-optionals-for-objc-programmers/</guid>
      <description>I&amp;rsquo;m trying my hand at some iOS programming after being away for a while. At this point it does not make sense to start a new project in Objective-C so I started in Swift.
Overall, Swift is very readable and I&amp;rsquo;m fairly productive right out of the gate. One of the new language features that not familiar though, is Optionals.
Due to Objective-C&amp;rsquo;s, C lineage you could do things like this:</description>
    </item>
    
    <item>
      <title>Omnifocus style reviews with org-mode</title>
      <link>https//dmitrym0.github.com/posts/omnifocus-review-with-org-mode/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/omnifocus-review-with-org-mode/</guid>
      <description>I started using Emacs and org-mode in earnest in the middle of 2019. At that point in time I was using Omnifocus to track my tasks and Bearapp for notes. I was missing plaintext functionality. Since then I&amp;rsquo;ve reproduced most of the functionality that Omnifocus offerred except one particular feature: reviews.
In GTD, reviews occupy a pretty important niche. Without regular task and project reviews task lists tend to grow out of control and become polutted.</description>
    </item>
    
    <item>
      <title>Reading a font from file an making it available to Cocoa</title>
      <link>https//dmitrym0.github.com/posts/reading-font-from-/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/reading-font-from-/</guid>
      <description>This is another programming related post.
Say you have a true type font that&amp;rsquo;s not part of the OS font set in a file. You&amp;rsquo;ve read the contents of the file into memory and now want to make it available to Cocoa. How?
Turns out that ATSUI comes to the rescue:
ATSFontContainerRef container; OSStatus status = ATSFontActivateFromMemory((LogicalAddress)[fontData bytes], // buffer with font data  [fontData length], // size of font data  kATSFontContextLocal, // for use only in this application  kATSFontFormatUnspecified, // reserved  NULL, // reserved  kATSOptionFlagsDefault, // reserved  &amp;amp;container); // on output, will contain the activated font // find the number of font references in the container (goes to numItems) ItemCount numItems; status = ATSFontFindFromContainer(container, kATSOptionFlagsDefault, 0, NULL, &amp;amp;numItems); NSLog(@&amp;#34;There are %d references in the container\n&amp;#34;, numItems); // load the individual fonts ATSFontRef *ioArray = malloc(numItems * sizeof(ATSFontRef)); status = ATSFontFindFromContainer(container, kATSOptionFlagsDefault, numItems, ioArray, &amp;amp;numItems); CFStringRef fontName = nil; ATSFontGetName (ioArray[fontIndex], kATSOptionFlagsDefault, &amp;amp;fontName); NSFont* myFont = [NSFont fontWithName:(NSString*)fontName size:24];  myFont now contains the NSFont reference to your font.</description>
    </item>
    
    <item>
      <title>Reading a font from file an making it available to Cocoa</title>
      <link>https//dmitrym0.github.com/posts/reading-font-from-file-an/</link>
      <pubDate>Tue, 07 Jan 2020 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/reading-font-from-file-an/</guid>
      <description>This is another programming related post.
Say you have a true type font that&amp;rsquo;s not part of the OS font set in a file. You&amp;rsquo;ve read the contents of the file into memory and now want to make it available to Cocoa. How?
Turns out that ATSUI comes to the rescue:
ATSFontContainerRef container; OSStatus status = ATSFontActivateFromMemory((LogicalAddress)[fontData bytes], // buffer with font data  [fontData length], // size of font data  kATSFontContextLocal, // for use only in this application  kATSFontFormatUnspecified, // reserved  NULL, // reserved  kATSOptionFlagsDefault, // reserved  &amp;amp;container); // on output, will contain the activated font // find the number of font references in the container (goes to numItems) ItemCount numItems; status = ATSFontFindFromContainer(container, kATSOptionFlagsDefault, 0, NULL, &amp;amp;numItems); NSLog(@&amp;#34;There are %d references in the container\n&amp;#34;, numItems); // load the individual fonts ATSFontRef *ioArray = malloc(numItems * sizeof(ATSFontRef)); status = ATSFontFindFromContainer(container, kATSOptionFlagsDefault, numItems, ioArray, &amp;amp;numItems); CFStringRef fontName = nil; ATSFontGetName (ioArray[fontIndex], kATSOptionFlagsDefault, &amp;amp;fontName); NSFont* myFont = [NSFont fontWithName:(NSString*)fontName size:24];  myFont now contains the NSFont reference to your font.</description>
    </item>
    
    <item>
      <title>test post 99</title>
      <link>https//dmitrym0.github.com/posts/post-title-in-slug-form-3/</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/post-title-in-slug-form-3/</guid>
      <description>this is a post</description>
    </item>
    
    <item>
      <title>Swift optionals for Objective-C programmers</title>
      <link>https//dmitrym0.github.com/posts/diy-lithium-battery-part-1/</link>
      <pubDate>Tue, 12 Mar 2019 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/diy-lithium-battery-part-1/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Safari App Extensions; migrating from .safariextz</title>
      <link>https//dmitrym0.github.com/posts/safari-app-extensions-migrating-from-safariextz/</link>
      <pubDate>Mon, 08 Oct 2018 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/safari-app-extensions-migrating-from-safariextz/</guid>
      <description>I’ve dabbled with a Safari extension for a project on and off for a while. For Safari 12, I read that .safariextz-style extensions are no longer supported. I went forth to investigate what changed and how I could port my old extension to Safari 12.
The short story is that the packaging has changed, but the bulk of the existing extension should just work once new conventions are adopted. I imagine the new changes are spurred by Apple’s desire to unify distribution — new extensions are wrapped as a mac application, require a signature and are distributed through the Mac App Store.</description>
    </item>
    
    <item>
      <title>How to check for X-Send-File (or X-Accel-Redirect)</title>
      <link>https//dmitrym0.github.com/posts/how-to-check-for-x-sendfile/</link>
      <pubDate>Tue, 11 Sep 2018 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/how-to-check-for-x-sendfile/</guid>
      <description>Some web requests should not be handled by the application framework. Requests hitting a dynamic API endpoint should be processed by application (in my case typically Ruby on Rails). Static assets (such as files) should be served by the webserver, bypassing Ruby on Rails completely.
Why?
There are a couple of reasons.
The biggest one is performance. NGINX and Apache are significantly better and faster at serving files than a Ruby process.</description>
    </item>
    
    <item>
      <title>Efficient commit workflow with tig</title>
      <link>https//dmitrym0.github.com/posts/tig-cheat-sheet/</link>
      <pubDate>Thu, 30 Aug 2018 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/tig-cheat-sheet/</guid>
      <description>One of the recommended source control practices is to commit frequently, and often. I prefer to keep my commits terse and focused, however in practice I’m working on a couple related but independent things in parallel. At commit time, I prefer to tease loosely related things apart and commit them separately.
One way to do that is with the interactive git-add facility that can be invoked with git add -p:</description>
    </item>
    
    <item>
      <title>ANother post</title>
      <link>https//dmitrym0.github.com/posts/post-title-in-slug-form-2/</link>
      <pubDate>Tue, 19 Dec 2017 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/post-title-in-slug-form-2/</guid>
      <description>test asdf</description>
    </item>
    
    <item>
      <title>Post Title</title>
      <link>https//dmitrym0.github.com/posts/post-title-in-slug-form-1/</link>
      <pubDate>Tue, 19 Dec 2017 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/post-title-in-slug-form-1/</guid>
      <description>Content test More content asdf Even more
echo &amp;#39;Some source code content&amp;#39; echo &amp;#39;This line will be highlighted&amp;#39; echo &amp;#34;This one won&amp;#39;t&amp;#34; </description>
    </item>
    
    <item>
      <title>XTerra Switched Outlet Howto</title>
      <link>https//dmitrym0.github.com/posts/xterra-switched-outlet-howto/</link>
      <pubDate>Thu, 23 Mar 2017 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/xterra-switched-outlet-howto/</guid>
      <description>XTerra Switched outlet For some reason truck and SUV 12v outlets are always hot. This is true in my wife’s F150 and my 2010 Nissan XTerra. This is a bit of annoyance since I’d like to use a bluetooth transmitter to connect my iPhone to the radio. Thankfully, it’s fairly easy to add a second, switched outlet in the XTerra.
The short of it is:
 acquire OEM cigarette outlet wire it via an add-a-fuse  As far as electrical mods go this one is very mild and simple.</description>
    </item>
    
    <item>
      <title>ncdu - ncurses disk usage</title>
      <link>https//dmitrym0.github.com/posts/ncdu-ncurses-disk-usage/</link>
      <pubDate>Wed, 07 Dec 2016 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/ncdu-ncurses-disk-usage/</guid>
      <description>At some point harddrive space was cheap, but with the advent of SSDs and cheap “Cloud VMs” that is no longer the case. For example, the cheapest VM on VULTR is $5/month and has a 15 gig SSD drive. It&amp;rsquo;s suddenly very important to maximize drive usage again. This is where ncdu comes in. It displays a nice ncurses interface that visualizes the usage breakdown.
So useful key bindings:</description>
    </item>
    
    <item>
      <title>RAID5: Recovering from 2-drive failure during rebuild</title>
      <link>https//dmitrym0.github.com/posts/raid5-multiple-disk-recovery/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/raid5-multiple-disk-recovery/</guid>
      <description>RAID is amazing technology. It lets us take a bunch of cheap disks an arrange them in various configurations that present these disks as one large disk. A particularly popular type of RAID for home users is RAID5. A RAID5 array is typically comprised of 3 disks, however only 2&amp;frasl;3 of the disk space is available since 1&amp;frasl;3 of the space is used for recovery purposes if one of the disks fail.</description>
    </item>
    
    <item>
      <title>tircd, irc twitter gateway</title>
      <link>https//dmitrym0.github.com/posts/tircd-twitter-gateway/</link>
      <pubDate>Sun, 17 Mar 2013 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/tircd-twitter-gateway/</guid>
      <description>I published my tircd branch. If you&amp;rsquo;re unfamiliar with tircd it&amp;rsquo;s a daemon that presents Twitter as an IRC channel. I merged this really old branch that implements Twitter lists as channels with the semi official google code mirror branch. I created a pull request but it hasn&amp;rsquo;t been acted on yet.
I consume my instant messaging via IRC (with the help of minbif) and now Twitter too. Quite convenient.</description>
    </item>
    
    <item>
      <title>Working with shared memory on OS X</title>
      <link>https//dmitrym0.github.com/posts/shared-memory-on-os-x/</link>
      <pubDate>Mon, 05 Apr 2010 00:00:00 -0700</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/shared-memory-on-os-x/</guid>
      <description>If you&amp;rsquo;re working with Qt&amp;rsquo;s QSharedMemory, on Mac OS X you&amp;rsquo;re working with System V shared memory subsystem. If your data is sizable, the first limit you&amp;rsquo;ll hit in the maximum segment size, which is for some reason around 4 megs. To increase it invoke this magic incantation:
sudo sysctl -w kern.sysv.shmmax=33554432 and to see other shared mem related kernel variables:
sysctl -A|grep shm If you&amp;rsquo;d like these settings to remain after you reboot your machine follow the instruction here.</description>
    </item>
    
    <item>
      <title>Reading a font from file an making it available to Cocoa</title>
      <link>https//dmitrym0.github.com/posts/reading-font-from-file-and-making-it-available-to-cocoa/</link>
      <pubDate>Fri, 06 Feb 2009 00:00:00 -0800</pubDate>
      
      <guid>https//dmitrym0.github.com/posts/reading-font-from-file-and-making-it-available-to-cocoa/</guid>
      <description>This is another programming related post.
Say you have a true type font that&amp;rsquo;s not part of the OS font set in a file. You&amp;rsquo;ve read the contents of the file into memory and now want to make it available to Cocoa. How?
Turns out that ATSUI comes to the rescue:
ATSFontContainerRef container; OSStatus status = ATSFontActivateFromMemory((LogicalAddress)[fontData bytes], // buffer with font data  [fontData length], // size of font data  kATSFontContextLocal, // for use only in this application  kATSFontFormatUnspecified, // reserved  NULL, // reserved  kATSOptionFlagsDefault, // reserved  &amp;amp;container); // on output, will contain the activated font // find the number of font references in the container (goes to numItems) ItemCount numItems; status = ATSFontFindFromContainer(container, kATSOptionFlagsDefault, 0, NULL, &amp;amp;numItems); NSLog(@&amp;#34;There are %d references in the container\n&amp;#34;, numItems); // load the individual fonts ATSFontRef *ioArray = malloc(numItems * sizeof(ATSFontRef)); status = ATSFontFindFromContainer(container, kATSOptionFlagsDefault, numItems, ioArray, &amp;amp;numItems); CFStringRef fontName = nil; ATSFontGetName (ioArray[fontIndex], kATSOptionFlagsDefault, &amp;amp;fontName); NSFont* myFont = [NSFont fontWithName:(NSString*)fontName size:24];  myFont now contains the NSFont reference to your font.</description>
    </item>
    
  </channel>
</rss>